%% Format tracks from the trackmate output .xml into cell arrays
% function to
% 1. filter tracks that are too short to analyze
% 2. zero the tracks data to common origin (output disps),
% 3. calculate and save (unscaled) velocities into tracks.
%
% INPUTS:
% 
%   filename: filename in ' ' or " " of the tracks xml corresponding to
%       the tracks generated by trackmate.
%       ex: '7.09UTURN_tracks.xml'
%   
%   varargin: A stand-in variable for the inputparser, which allows inputs
%             to be optional and take default values when not explicitly given.
%
%   Optional POSITIONAL Inputs:
%
%       Labels: filename in ' ' or " " of the label image stack corresponding to
%       the tracks generated by trackmate after tracking. Used to tag each
%       track with its Label value. Used in domain analysis.
%       ex: "uplabelstest.tif"
%
%   Optional NONpositional Inputs: (mindur, stimstart)
%
%       mindur: minimum duration, in frames, of the tracks to analyze.
%       Default 10
%
%       stimstart: frame number when (forward) stim starts, used to truncate out
%       the control period. Use 0 for no control. Default 0
%
% 
% OUTPUTS:
%
%   tracks: cell array, one cell for each track. Each track contains 6
%       columns, in order: frame (t), x pos, y pos, track ID, dx, dy
%
%   disps: tracks{:,1}(:,1:4) subtracting initial x y position, so that each track begins at
%       (0,0).
%
%
%Hailey Currie
%Summer 2025
%
function [tracks, disps]=TracksForm(filename,mindur,stimstart,varargin)

%% Input Parser
%Input parser efficiently sets defaults for inputs and checks if given
%inputs are valid/correct data type. Parameters are not positional, so the
%function must be fed the variable name and new value when called if not
%using defaults. ex: Tracksform(filename, mindur = 15). Unmentioned variables default.
p = inputParser;

% For doing various checks on the inputs
valid_positive_integer = @(x) isnumeric(x) && isscalar(x) && (x > 0) && (mod(x,1)<eps); % last check enforces integer
% valid_positive_integer_array = @(x) isnumeric(x)  && sum(x > 0)==length(x) && sum((mod(x,1)<eps))==length(x); % last check enforces integer
%valid_positive_number = @(x) isnumeric(x) && isscalar(x) && (x > 0);

%Optional labels files for label tagging. These are positional
%and must come before other optional variables. NOT passed in the same way
%as "Parameters' below. Just provide filename in '' like the first
addOptional(p,'Labels',[], @mustBeText); 

% Default values, and check validity
addParameter(p,'mindur', 10, valid_positive_integer); %Minimum duration of track (frames). Default 10
addParameter(p,'stimstart', 0, valid_positive_integer); %First frame of stim (crop tracks to begin here). Default 0

parse(p, varargin{:});

%To check if any inputs did nothing/were not interpreted:
if ~isempty(fieldnames(p.Unmatched))
   disp('Extra inputs:')
   disp(p.Unmatched)
end

%To see which variables were set to their defaults, and what those values
%are:
if ~isempty(p.UsingDefaults)
   disp('Using defaults: ')
   disp(p.UsingDefaults)
end

%Call & rename variables from parser data structure
Labels = p.Results.Labels;
mindur = p.Results.mindur;
stimstart = p.Results.stimstart;


%% import tracks (must add FIJI to path to use this fxn)
tracks=importTrackMateTracks(filename);

%% Optionally, tag the tracks with Label IDs

if isempty(Labels)==0
    labels=tiffreadVolume(Labels);
    
    for i=1:length(tracks)
        pos=floor(tracks{i}(1,2:3));
        f=tracks{i}(1,1);
        tracks{i}(:,4)=labels(pos(2),pos(1),f+1);
    end
end 

%% crop at stimstart

for i=1:length(tracks)
    tracks{i,1}(:,4)=i; 
    tracks{i,1}=tracks{i,1}((stimstart+1):end,:); %crop pre-stim control (set stimstart to 0 to include control in analysis)
end

%% remove tracks less than the minimum duration (see note in readme)
I=find(cellfun(@length,tracks)>mindur);
tracks=tracks(I);


%% create disps: set initial (x,y)=(0,0) for each track (a la hairball)
disps=tracks;
for i=1:size(tracks,1) %iterate over each track in the cell array
    %subtract first value in x from x positions in column 2
    disps{i,1}(:,2)=disps{i,1}(:,2)-disps{i,1}(1,2);
    %subtract first value in y from y positions in column 3
    disps{i,1}(:,3)=disps{i,1}(:,3)-disps{i,1}(1,3);
    
    %calculate frame-frame x and y displacements (velocity in px/frame)
    for f=2:length(disps{i,1}(:,1)) %iterate over frames of track i
        %calculate steps in x and y in column 5 and 6 ("velocity" in px/frame)
        tracks{i,1}(1,5)=0;
        tracks{i,1}(f,5)=disps{i,1}(f,2)-disps{i,1}(f-1,2);
        tracks{i,1}(1,6)=0;
        tracks{i,1}(f,6)=disps{i,1}(f,3)-disps{i,1}(f-1,3);
        
        % %smooth velocity by averaging over past 3 frames
        % tracks{i,1}(1:4,7)=0;
        % if f>4
        % tracks{i,1}(f,7)=mean(tracks{i,1}(f-3:f,6));
        % end
    end
end



